#include <unordered_map>
#include <vector>
#include <string>
//#include <iostream>

#include "lzw.h"
#include "bitio.h"

typedef unsigned int    Uint;
typedef unsigned char   Uchar;

static constexpr size_t Uint_len  = sizeof(Uint)*8;
static constexpr size_t Uchar_len = sizeof(Uchar)*8;

// Example: TOBEORNOTTOBEORTOBEORNOT#
//
// Initial table:
// 
// Symbol  Binary  Decimal
// ------  ------  -------
// #       00000    0
// A       00001    1
// B       00010    2
//         .
//         .
//         .
//
// Z       11010   26

// Critical values for emitting clear_code.
// Used in monitoring compression efficiency.
// cri_len: ++missed if str_len <= cri_len
// cri_num: issue clear_code if missed >= cri_num
static constexpr int cri_len = 3;
static constexpr int cri_num = 15;

static constexpr Uint max_code   = 65535;
static constexpr Uint init_code  = 255; // last code of initial dictionary
static constexpr Uint clear_code = init_code + 1;
static constexpr Uint stop_code  = clear_code + 1;

static constexpr Uint max_size_default = 512; // power of 2 that > stop_code
static constexpr Uint new_code_default = stop_code + 1;
static constexpr Uint bit_len_default  = 9;   // 2^bit_len = max_size

namespace {
    struct Hash {
        constexpr size_t operator()(Uint n) const {
            return n;
        }
    };
}

static Uint read_char(std::ifstream& fin) {
    char c;
    if (!fin.get(c)) {
        return stop_code;
    }
    else {
        return (Uint)(Uchar)c;
    }
}

static constexpr Uint pair(Uint code, Uint ch) {
    return (code << Uchar_len) | ch;
}

// Encoding:
//
// Current  Code Of  Output code  Extend dict  Comment
// -------  -------  -----------  -----------  -------
// TO       T        20  10100    27: TO
// OB       O        15  01111    28: OB
// BE       B         2  00010    29: BE
// EO       E         5  00101    30: EO
// OR       O        15  01111    31: OR
// RN       R        18  10010    32: RN       32 need 6 bits, start 6 bit.
// NO       N        14 001110    33: NO
// OT       O        15 001111    34: OT
// TT       T        20 010100    35: TT
// TOB      TO       27 011011    36: TOB
// BEO      BE       29 011101    37: BEO
// ORT      OR       31 011111    38: ORT
// TOBE     TOB      36 100100    39: TOBE
// EOR      EO       30 011110    40: EOR
// RNO      RN       32 100000    41: RNO
// OT#      OT       34 100010
//                    0 000000                 stop code
//
// Current  Code Of  Output code      Extend dict  Comment
// -------  -------  ---------------  -----------  -------
// **       *         42 0 0010 1010  258: **
// **#      **       258 1 0000 0010  
//                   257 1 0000 0001               stop code
//

// One unit: One filled dictionary.
// Return true if read stop_code (compressed whole file), else return false.
static bool lzw_c_unit(std::ifstream& fin, BitWriter& writer) {
    Uint max_size = max_size_default;
    Uint new_code = new_code_default;
    Uint bit_len  = bit_len_default;

    typedef Uint Pair; // last 8 bits store character, other store code
    typedef Uint Code;
    std::unordered_map<Pair, Code, Hash> dict;
    dict.reserve(max_code + 1);

    // Initialize dictionary.
    for (Uint i = 0; i <= init_code; ++i) {
        dict[i] = i;
    }

    Uint cur_code = 0;
    Uint cur_char = read_char(fin);

    // If file is empty.
    if (cur_char == stop_code) {
        writer.write(stop_code, bit_len);
        writer.flush();
        return true;
    }

    int str_len = 0;
    int missed  = 0;

    // Start encoding.
    while (cur_char != stop_code) {
        Uint p = pair(cur_code, cur_char);

        // Read until that string not in dict.
        if (dict.count(p)) {
            cur_code = dict[p];
            str_len += 1;
        }

        // Output code[prefix(string)], add string to dict
        else {
            writer.write(cur_code, bit_len);

            // Extend dict if new_code <= max_code
            if (new_code <= max_code) {
                dict[p] = new_code;
                if (new_code == max_size) {
                    max_size <<= 1;
                    bit_len += 1;
                }
                new_code += 1;
            }
            else { // dict has full, monitor compression rate
                if (str_len <= cri_len) {
                    missed += 1;
                    if (missed >= cri_num) { // compression rate low
                        fin.putback(cur_char);
                        writer.write(clear_code, bit_len);
                        return false;
                    }
                }
                else {
                    if (missed > 0) {
                        missed -= 1;
                    }
                }
            }
            cur_code = dict[pair(0, cur_char)];
            str_len = 1;
        }
        cur_char = read_char(fin);
    }

    writer.write(cur_code, bit_len);
    writer.write(stop_code, bit_len);
    writer.flush();
    return true;
}

void lzw_c(std::ifstream& fin, std::ofstream& fout) {
    BitWriter writer(fout);
    while (!lzw_c_unit(fin, writer)) {}
}

static void write_str(std::ofstream& fout, const std::string& str) {
    fout.write(str.data(), str.size());
}

// Decoding:
//
// Input code  Seq   Extend dict      Comments
// ----------  ----  ---------------  --------
//  10100 20   T     27 T?   -> TO
//  01111 15   O     28 O?   -> OB
//  00010  2   B     29 B?   -> BE
//  00101  5   E     30 E?   -> EO
//  01111 15   O     31 O?   -> OR
//  10010 18   R     32 R?   -> RN    32 need 6 bits, start 6 bit
// 001110 14   N     33 N?   -> NO
// 001111 15   O     34 O?   -> OT
// 010100 20   T     35 T?   -> TT
// 011011 27   TO    36 TO?  -> TOB
// 011101 29   BE    37 BE?  -> BEO
// 011111 31   OR    38 OR?  -> ORT
// 100100 36   TOB   39 TOB? -> TOBE
// 011110 30   EO    40 EO?  -> EOR
// 100000 32   RN    41 RN?  -> RNO
// 100010 34   OT    42 OT?
// 000000  0                          stop code
//
// Input code       Seq  Extend dict    Comment
// ---------------  ---  -------------  -------
// 0 0010 1010  42  *    258 *?  -> **
// 1 0000 0010 258  **   259 **?
// 1 0000 0001                          stop code
//

// Return true if read stop_code (compressed whole file), else return false.
static bool lzw_x_unit(BitReader& reader, std::ofstream& fout) {
    Uint max_size = max_size_default;
    Uint new_code = new_code_default;
    Uint bit_len  = bit_len_default;

    // Initialize dictionary.
    std::vector<std::string> dict(max_code + 1);
    for (Uint i = 0; i <= init_code; ++i) {
        dict[i] = std::string(1, (char)i);
    }

    // Read code.
    Uint cur_code = 0;
    reader.read(cur_code, bit_len);
    if (cur_code == stop_code) {
        return true;
    }

    // Write answer.
    write_str(fout, dict[cur_code]);

    // Add code.
    dict[new_code] = dict[cur_code];

    // Repeat: Read code, decode, write answer, add code.
    while (reader.read(cur_code = 0, bit_len) && cur_code != stop_code) {
        if (cur_code == clear_code) {
            return false;
        }
        if (new_code < max_code) {
            dict[new_code] += dict[cur_code][0];
            new_code += 1;
            if (new_code == max_size) {
                max_size <<= 1;
                bit_len += 1;
            }
            dict[new_code] = dict[cur_code];
        }
        else if (new_code == max_code) {
            dict[new_code] += dict[cur_code][0];
            new_code += 1;
        }
        write_str(fout, dict[cur_code]);
    }

    return true;
}

void lzw_x(std::ifstream& fin, std::ofstream& fout) {
    BitReader reader(fin);
    while (!lzw_x_unit(reader, fout)) {}
}

